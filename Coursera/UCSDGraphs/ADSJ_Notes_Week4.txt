Advanced Data Structures in JAVA - Week 4 Notes

Learning Objectives

1.	Describe Breadth First Search's value for an unweighted graph
	-	once the searched node is reached we have found the shortest path. Anything coming after this route will be longer.
    
2.	Explain Breadth First Search's limitations for graphs with weighted edges 
	Still the BFS searches for the less amount of nodes to reach the destiny, therefore this is not the shortest path!

3.  Apply Dijkstra's Algorithm to a weighted graph 
	Priority Queue: list where to add an {element, priority} to one end and remove the highest priority item from the other
	-	enqueue	->	add and element, priority}
	-	dequeue ->	remove the highest priority element
	Can be implemented using a Heap, which can prioritize low values (Min-Heap) or large values (Max-Heap)
	
4.  Write the code to implement Dijkstra's Algorithm
	Dijkstra (S, G):
	Initialize Priority queue (PQ), visited HashSet and parent HashMap and distances to infinity
	Enqueue S, 0 onto the queue 
	while queue is not empty:
		dequeue node curr from front of queue
		If Curr is not visited)
			add curr to visited set
			if curr == G return parent map
			for each of curr's neighbors, n, not in visited set:
				if path through curr to n is shorter
					update n's distance
					update curr as n's parent in parent map
					enqueue (n, distance) into the PQ
	// if we get here there is no path

5.  Describe how the ADT Priority Queue works 


6.  Describe how Priority Queues are used in Dijkstra's Algorithm 


7.  Describe a limitation of Dijkstra's Algorithm 
	-	it only considers distance from the source! We should consider how far we are from the target.
	-	Priority Queue ordering is based on:
		g(n): the distance (cost) from start vertex to vertex n. 

8.  Apply the A* search algorithm to a weighted graph.
	-	The A* algorithm uses ordering of the Priority Queue based on:
		g(n): the distance (cost) from start vertex to vertex n 
		AND
		h(n): the heuristic estimated cost from vertex n to goal vertex!
		
		function f(n) = g(n) + h(n). Dijkstra is the same only h(n) = 0.
		It is guaranteed to find the shortest path IF estimate h(n) is never an overestimate -> use straight line!
    
9.	Write the code for A* search

	Initialize open and closed lists
	Make the start vertex current
	Calculate heuristic distance of start vertex to destination (h)
	Calculate f value for start vertex (f = g + h, where g = 0)
	WHILE current vertex is not the destination
		FOR each vertex adjacent to current
			IF vertex not in closed list and not in open list THEN
				Add vertex to open list
				Calculate distance from start (g)
				calculate heuristic distance to destination (h)
				Calculate f value (f = g + h)
				IF new f value < existing f value or there is no existing f value THEN
					Update f value
					Set parent to be the current vertex
				END IF
			END IF
		NEXT adjacent vertex
		add current vertex to closed list
		Remove vertex with lowest f value from open list and make it current
	END WHILE
					

